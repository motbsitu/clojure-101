<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1447439080372">{:repl-history {:ide [], :local [&quot;(def promise-later (promise))&quot; &quot;(future \n  (println \&quot;I'm waiting for the answer\&quot;)\n  (println \&quot;And the answer is\&quot; @promise-later))&quot; &quot;(deliver promise-later 42)&quot; &quot;(def delay-answering (delay (println \&quot;working on the answer\&quot;)\n                            (rand-int 10)))&quot; &quot;(def delay-answering \n  (delay (println \&quot;working on the answer\&quot;)\n                            (rand-int 10)))&quot; &quot;@delay-answering&quot; &quot;(map #(do (println \&quot;generating the\&quot; % \&quot;th answer\&quot;) %)\n     (range 10))&quot; &quot;(pmap #(do (println \&quot;generating the\&quot; % \&quot;th answer\&quot;) %)\n     (range 10))&quot; &quot;(map inc (range))&quot; &quot;\n(def bigger-numbers (map inc (range)))&quot; &quot;(first lazy-loopy)&quot; &quot;(def bigger-numbers (map inc (range)))&quot; &quot;(first bigger-numbers)&quot; &quot;(defn lazy-loopy [x]\n  (when (pos? x)\n    (lazy-seq\n      (println \&quot;Adding\&quot; x \&quot;to the seq\&quot;)\n      (cons x (lazy-loopy (dec x))))))&quot; &quot;(def numbers (lazy-loopy 5))&quot; &quot;(first numbers)&quot; &quot;(nth 4 numbers)&quot; &quot;(map #(do (println \&quot;generating answer #\&quot; %) %)\n     (range 10))&quot; &quot;(pmap #(do (println \&quot;generating answer #\&quot; %) %)\n     (range 10))&quot; &quot;(clojure.java.io/reader \&quot;project.clj\&quot;)&quot; &quot;(map count lines)&quot; &quot;(filter pos? line-counts)&quot; &quot;(def lines\n  (line-seq (clojure.java.io/reader \&quot;project.clj\&quot;)))&quot; &quot;(first)&quot; &quot;(first lines)&quot; &quot;(second lines)&quot; &quot;(third lines)&quot; &quot;(def line-counts (map count lines))&quot; &quot;line-counts&quot; &quot;(def pos-line-counts (filter pos? line-counts))&quot; &quot;pos-line-counts&quot; &quot;(def total-characters (reduce + pos-line-counts))&quot; &quot;total-characters&quot; &quot;(double (/ total-characters (count lines)))&quot; &quot;(hash-map :a 1, :b 2 :c 3)&quot; &quot;(assoc {:a 1 :b 2} :c 3)&quot; &quot;(assoc {:a 1 :b 2 :c 3} :b)&quot; &quot;(dissoc {:a 1 :b 2 :c 3} :b)&quot; &quot;(conj {:a 1 :b 2} [:c 3])&quot; &quot;(vec (range 5))&quot; &quot;(vector 0 1 2 3 4)&quot; &quot;(conj [1 2 3 4] 5)&quot; &quot;(subvec [1 2 3 4 5] 1 3)&quot; &quot;(get [1 2 3 4 5] 2)&quot; &quot;([1 2 3 4 5] 2)&quot; &quot;(get [1 2 3 4 5] 7 :not-found)&quot; &quot;(set #{1 2 3})&quot; &quot;(conj #{1 2 3} 4)&quot; &quot;(disj #{1 2 3} 2)&quot; &quot;(contains? #{1 2 3} 2)&quot; &quot;(#{1 2 3} 2)&quot; &quot;(list 1 2 3)&quot; &quot;(cons 0 '(1 2 3))&quot; &quot;(conj '(1 2 3) 0)&quot; &quot;(type (cons 0 '(1 2 3)))&quot; &quot;(type (conj '(1 2 3) 0))&quot; &quot;(first '(1 2 3))&quot; &quot;(rest '(1 2 3))&quot; &quot;(dissoc [1 2 3] 0)&quot; &quot;(let [[a b c] (range 5)])&quot; &quot;(let [[a b c] (range 5)]\n  [a b c])&quot; &quot;(let [[a b &amp; the-rest] (range 5)]\n  [a b the-rest])&quot; &quot;(sequence-binding-example [1 2 \&quot;bucle my shoe\&quot; 3 4])&quot; &quot;(sequence-binding-example [1 2 \&quot;buckle my shoe\&quot; 3 4])&quot; &quot;(map-binding-example {:a 1 :b 3 :c :rabbit :d 4})&quot; &quot;'(d (c (b (a 1) 2) 3) 3)&quot; &quot;(-&gt; (a 1) (b 2) (c 3) (d 4))&quot; &quot;(-&gt; (a 1) \n    (b 2) \n    (c 3) \n    (d 4))&quot; &quot;'(d \n   (c \n     (b \n       (a 1) \n       2) \n     3) \n   3)&quot; &quot;(let [t 42]\n  (if (neg? t) \n    :brrr\n    (if (&lt; 150)\n      :hot\n      :ok)))&quot; &quot;(let [t 42]\n  (cond \n    (neg? t) :brr\n    (&lt; 150)  :hot\n    :other   :ok))&quot; &quot;(let [t 42]\n  (cond \n    (neg? t) :brr\n    (&gt; 110)  :hot\n    :other   :ok))&quot; &quot;(let [t 42]\n  (cond \n    (neg? t) :brr\n    (&gt; t 110)  :hot\n    :other   :ok))&quot; &quot;(let [t 42]\n  (if (neg? t) \n    :brrr\n    (if (&gt; t 110)\n      :hot\n      :ok)))&quot; &quot;(let [t 42]\n  (if (neg? t) \n    :brrr\n    (if (&gt; t 110)\n      :hot\n      (if (&lt; t 80)))))&quot; &quot;(let [t 42]\n  (if (neg? t) \n    :brrr\n    (if (&gt; t 110)\n      :hot\n      (if (&lt; t 80)\n        :brisk\n        :warm))))&quot; &quot;(let [t 42]\n  (cond \n    (neg? t)  :brr\n    (&gt; t 110) :hot\n    (&lt; t 80)  :brisk\n    :default  :warm))&quot; &quot;(macroexpand-1\n  '(-&gt; (a 1) \n       (b 2) \n       (c 3) \n       (d 4))\n&quot; &quot;(macroexpand-1\n  '(-&gt; (a 1) \n       (b 2) \n       (c 3) \n       (d 4)))\n&quot; &quot;(def myFile (clojure.java.io/writer \&quot;out.txt\&quot;))&quot; &quot;(def data [\&quot;line1\&quot; \&quot;line2\&quot; \&quot;line3\&quot;])&quot; &quot;(for [line data]\n  (.write myFile line))&quot; &quot;(.close myFile)&quot; &quot;(for [line data]\n  (.write myFile line)\n  (.write myFile \\newline))&quot; &quot;(doseq [x (range 5)]\n  (println 5))&quot; &quot;(doseq [x (range 5)]\n  (println x))&quot; &quot;(output \&quot;out.txt\&quot; data)&quot; &quot;(slurp \&quot;out.txt\&quot;)&quot; &quot;(for [x (range 0 9)])&quot; &quot;(for [x (range 0 9)]\n  (println x))&quot; &quot;(for [x (range 0 9)]\n  x)&quot; &quot;(def result (for [x (range 0 9)] x))&quot; &quot;(def result (for [x (range 0 9)]\n  (println x)))&quot; &quot;(def result (doseq [x (range 0 9)]\n  (println x)))&quot; &quot;result&quot; &quot;(clojure.string/capitalize \&quot;hi\&quot;)&quot; &quot;(require '[cljure.string :require [capitalize]])&quot; &quot;(require '[cljure.string :refer [capitalize]])&quot; &quot;(require '[clojure.string :refer [capitalize]])&quot; &quot;(capitalize \&quot;hi\&quot;)&quot;], :remote []}}</component>
</project>